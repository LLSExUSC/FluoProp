% Main script for Calcium propagation velocity calculations 
%
% Andrew Petersen 2019 12 19
%


%% temp holding area
inputPath1 = 'C:\Users\Andrew\Desktop\MATLABData\conduct3\1Hz_int100_roi03_20V_001.nd2'
inputPath10 = 'C:\Users\Andrew\Desktop\MATLABData\conduct3\HG+S_4h_Norm_NRVM_1Hz_pointUpperlft_01011.nd2'
inputPath20 = 'C:\Users\Andrew\Desktop\MATLABData\addedData_conduct1_2\Raw\20170717\CS2T_1hz_int25_roi03_2x_binning8_full_100fps_012.nd2'
inputPath22 = 'C:\Users\Andrew\Desktop\MATLABData\addedData_conduct1_2\Raw\20170717\CS2L_1hz_int25_roi01_2x_binning8_full_100fps_013.nd2'
inputPath30 = 'C:\Users\Andrew\Desktop\MATLABData\Cardiac Data\bmes\Raw\20170206\CS9_1hz_int100_roi02_2x_binning2_full_100fps_widefield_110.nd2'
inputPath31 = 'C:\Users\Andrew\Desktop\MATLABData\Cardiac Data\bmes\Raw\20170123\CS13_1hz_int100_roi04_2x_binning2_full_100fps_widefield_004.nd2'


%% Input Parameters 
% Change these variables to match your experimental conditions
inputPath = inputPath20; %Path of video file to read
parentSavePath = 'C:\Users\Andrew\Desktop\MATLABData\conduct4\2020_output3' %path where folder of output data will be made
micronToPixel = 26 %the actual size of each pixel in microns 
framesPerSecond = 100 
pacingFreq = 1 %in Hz
rejectThreshFirstBeat = 0.9 %fraction of first identified activation cycle required to accept it
rejectThreshLastBeat = 0.8 %fraction of last identified activation cycle required to accept it

% Automatically generated parameters (Don't change these!)
fileID = [getFilenameInPath(getParentPath(inputPath)),filesep,getFilenameInPath(inputPath)] 
saveFolder = [parentSavePath,filesep,fileID] 
mkdir(saveFolder)
rotationAngle = 0; %stays zero if rotation section not used
numberOfROIs = 1; %run the "Choose ROIs" section if multiple ROIs are desired
hasChosenROI = false;


%% Load Video File 
% Loads the file located at the specified path
[rawData,dataSize] = readFluoMovie(inputPath);
% rawData= fliplr(rawData); %to flip the video left to right
% rawData = rawData(:,:,2:end);  %Remove first frame because timing is sometimes waay off %only for Zyla/Nikon .nd2 videos
% dataSize = size(rawData);
ROIBoundsHolder = {[1,dataSize(1),1,dataSize(2)]};


%% Assess Video
% Calculates the standard deviation of each pixel, then displays it as an image
stdImage = std(rawData,0,3);
figID = 90001;
displayImageAutoscaled(stdImage,figID)
title(['StdImage - ',fileID],'Interpreter','none')
savefig(figID,[saveFolder,filesep,'StdImage.fig'])
saveas(figID,[saveFolder,filesep,'StdImage.png']);


%% Rotate Video to Align (Optional)
% Allows user to rotate the input video by rotating a rectangle. A dialog
% will ask after 10 seconds if rotation is finished. This only rotates; it
% does not crop.
figID = 90002;
[rotatedImage,rotationAngle] = alignImage(stdImage,figID,fileID);


%% Choose ROIs for Analysis. (Optional)
% Asks the user to manually resize and drag a rectangle to choose an ROI.
% Users can choose multiple ROIs. Skipping this section will use the entire
% field of view as a single ROI. All ROIs can be further cropped later. 
figID = 90003;
rotatedImage = imrotate(stdImage,rotationAngle,'bilinear','crop');
displayImageAutoscaled(rotatedImage,figID)
numberOfROIs = 1;

% autogenerated or manual rectangle?
answer = questdlg('Manually Draw ROIs or Automatically Generate?', ...
    'Manual vs Automatic', ...
    'Manually Draw','Automatically Generate','Automatically Generate');
if strcmp(answer,'Manually Draw') 
    ROIBoundsHolder = cell(0,0);% setup ROI bounds data structure
    choosingROIs = true;
    while choosingROIs
        % draw one
        [~,ROIBounds,~] = cropImage(rotatedImage,figID,['Horizontal ',fileID]);
        ROIBoundsHolder{numberOfROIs} = ROIBounds;
        
        % add ROI box and label to image
        
        % draw another?
        answer = questdlg('Choose another ROI?', ...
        'Another ROI?', ...
        'Yes','No','No');
        
        if strcmp(answer,'Yes') 
            % yes, increment numberOfROIs
            numberOfROIs = numberOfROIs + 1;
        elseif strcmp(answer,'No') 
            choosingROIs = false;
        end
    end
elseif strcmp(answer,'Automatically Generate') 
    error('Not yet implemented.')
    
%     generatingROIs = true;
%     while generatingROIs
%         %do auto system    %inputs: height, length, distance apart, starting X, starting Y, and number of ROIs
%         prompt = {'Enter ROI Height:','Enter ROI Length:','Enter Distance Between ROIs:', ...
%             sprintf('Enter Starting Pixel Row (1-%.0f):',dataSize(1)), ... 
%             sprintf('Enter Starting Pixel Column (1-%.0f):',dataSize(2)), ... 
%             'Enter Number ROIs:'};
%         dlgtitle = 'Input';
%         dims = [1 35];
%     %     definput = {'20','hsv'};
%         answer = inputdlg(prompt,dlgtitle,dims)%,definput)
%         
%         
%         
%         displayImageAutoscaled(rotatedImage,figID)
%         title('Chosen ROIs')
%         hold on;
%         pos = boundingBoxWidths;
%         points = cell(numRows,numCols);
%         boundingBoxes = cell(numRows,numCols);
%         currentROI = 1;
%         for g=1:numRows %tissue rows
%             thisPos = [pos(1)+(k-1)*horizDist,pos(2)+(g-1)*vertDist,pos(3),pos(4)];
%             points{g,k} = thisPos;
%             boundingBoxes{g,k} = [thisPos(2),thisPos(2)+thisPos(4)-1,thisPos(1),thisPos(1)+thisPos(3)-1];
%             rectangle('Position',points{g,k},'LineWidth',1)
%             text(thisPos(1),thisPos(2)+thisPos(4)+10,num2str(currentROI),'HorizontalAlignment','left','FontWeight','bold','fontsize',10);
%             currentROI = currentROI + 1;
%         end
%         rectangle('Position',[pos(1),pos(2),pos(3),pos(4)],'LineWidth',1,'EdgeColor','r')
%         %numberOfROIS = ?
%         
%         answer = questdlg('Accept generated ROIs?', ...
%         'Accept ROIs?', ...
%         'Yes','No','Yes');
%         if strcmp(answer,'Yes') 
%             generatingROIs = false;
%         end
%     end
end
hasChosenROI = true
disp('Finished Choosing ROIs')

%% Separate Activation Cycles
% Automatically calculate when each cycle begins and ends. Then remove any
% cycles that are likely incomplete. 

expectedNumberBeats = (dataSize(3)/framesPerSecond)*pacingFreq

numOfFrames = dataSize(3)
meanData = reshape(mean(mean(rawData,2),1),[1,numOfFrames]);
%Calculate where each beat begins and ends
breakIndexes = breakIntoBeats(meanData);
numBeats = length(breakIndexes)-1;
if numBeats<=1
    warning('No beats detected: %s',inputPath)
    return
end
figID = 90004;
figure(figID);
clf;
figure(figID);
plot(meanData,'b-','LineWidth',2)
hold on
%plot(breakIndexes,zeros(1,numBeats+1)+mean(meanData),'*r')
breakPeriods = diff(breakIndexes);

% Remove beats that are incomplete
% Anything with less than 90% of a beat is automatically removed from the
% beginning and 80% from the end (default values can be changed)
framesRequiredFirstBeat = rejectThreshFirstBeat*framesPerSecond/pacingFreq;
framesRequiredLastBeat = rejectThreshLastBeat*framesPerSecond/pacingFreq;

if breakPeriods(1) < framesRequiredFirstBeat
    breakIndexes = breakIndexes(2:end);
    numBeats = numBeats-1;
    warning('Removed first beat because less than %.0f%% of the beat was detected.',rejectThreshFirstBeat*100)
end
if breakPeriods(end) < framesRequiredLastBeat
    breakIndexes = breakIndexes(1:end-1);
    numBeats = numBeats-1;
    warning('Removed last beat because less than %.0f%% of the beat was detected.',rejectThreshLastBeat*100)
end
breakPeriods = diff(breakIndexes); %Recalculate beat periods with removed beats
for ew = 1:length(breakIndexes)
    plot([breakIndexes(ew),breakIndexes(ew)],[min(meanData),max(meanData)],'r--','LineWidth',2)
end
title([sprintf('%d Beats Detected - ',numBeats),fileID],'Interpreter','none')
xlabel('Time (frames)')
savefig(figID,[saveFolder,filesep,'BeatsDetected.fig'])
saveas(figID,[saveFolder,filesep,'BeatsDetected.png']);


%% Process Activation Cycles

%Manually crop actMap for first beat, use same crop for remaining beats
firstBeat = rawData(:,:,breakIndexes(1):breakIndexes(2));
actMapFrames= calculateActivationMap(firstBeat);
framePeriodms = (1000./framesPerSecond);
actMap = actMapFrames.*framePeriodms;
rotatedActMap = imrotate(actMap,rotationAngle,'bilinear','crop');
cropBoundsHolder = cell(numberOfROIs);
for currentROI = 1:numberOfROIs
    figID = figID + 1;
    ROIBounds = ROIBoundsHolder{currentROI};
    currentROIActMap = rotatedActMap(ROIBounds(1):ROIBounds(2),ROIBounds(3):ROIBounds(4));
    [~,cropBounds,~] = cropImage(currentROIActMap,figID,['Horizontal ',fileID]);
    cropBoundsHolder{currentROI} = cropBounds;
    savefig(figID,[saveFolder,filesep,sprintf('CroppedROI%02.0f.fig',currentROI)])
    saveas(figID,[saveFolder,filesep,sprintf('CroppedROI%02.0f.png',currentROI)]);
end
conductionOutput = zeros(numBeats*numberOfROIs,4);
outputIndex = 1;
for beat = 1:numBeats
    %Calculate activation map for each beat
    singleBeat = rawData(:,:,breakIndexes(beat):breakIndexes(beat+1));
    actMapFrames= calculateActivationMap(singleBeat);
    framePeriodms = (1000./framesPerSecond);
    actMap = actMapFrames.*framePeriodms;
    %Display activation map`
    figID = figID+1;
    displayImageAutoscaled(actMap,figID)
    title(['Activation Map - Beat ',num2str(beat),'. ',fileID],'Interpreter','none')
    xlabel('Pixels')
    ylabel('Pixels')
    axis equal
    cb = colorbar;
    ylabel(cb, 'Activation Time (ms)')
    savefig(figID,[saveFolder,filesep,sprintf('ActMap_Beat%02d.fig',beat)])
    saveas(figID,[saveFolder,filesep,sprintf('ActMap_Beat%02d.png',beat)]);
    for currentROI = 1:numberOfROIs
        %Crop if needed
        rotatedActMap = imrotate(actMap,rotationAngle,'bilinear','crop');
        ROIBounds = ROIBoundsHolder{currentROI};
        currentROIActMap = rotatedActMap(ROIBounds(1):ROIBounds(2),ROIBounds(3):ROIBounds(4));
        cropBounds = cropBoundsHolder{currentROI};
        croppedActMap = currentROIActMap(cropBounds(1):cropBounds(2),cropBounds(3):cropBounds(4));

        figID = figID+1;
        displayImageAutoscaled(croppedActMap,figID)
        axis equal
        title(sprintf('Activation Map, ROI%02.0f, Beat%02d, %s',currentROI,beat,fileID),'Interpreter','none')
        xlabel('Pixels')
        ylabel('Pixels')
        cb = colorbar;
        ylabel(cb, 'Activation Time (ms)')
        savefig(figID,[saveFolder,filesep,sprintf('CroppedActMap_ROI%02.0f_Beat%02d.fig',currentROI,beat)])
        saveas(figID,[saveFolder,filesep,sprintf('CroppedActMap_ROI%02.0f_Beat%02d.fig',currentROI,beat)]);

        %Flip Left Right (flips horizontally) Toggle at beginning of script
    %     if flip
    %         actMap = fliplr(actMap);
    %     end

        %Autoscale actMap for better viewing

        %Calculate CPV for this beat
        figID = figID+1;
        heatmapFigNum = figID;
        figID = figID+1;
        pointPlotFigNum = figID;
        [conductionHoriz,fitStats] = opticalMappingFit(croppedActMap,micronToPixel,heatmapFigNum,pointPlotFigNum,sprintf('ROI%02.0f_Beat%02d_%s',currentROI,beat,fileID))
        robust_s = fitStats.robust_s; % lower is better, robust_s is a robust estimate of the root mean square error (commonly called sigma) of the fit
        conductionOutput(outputIndex,1) = currentROI;
        conductionOutput(outputIndex,2) = beat;
        conductionOutput(outputIndex,3) = conductionHoriz;
        conductionOutput(outputIndex,4) = robust_s;
        outputIndex = outputIndex + 1;
        savefig(heatmapFigNum,[saveFolder,filesep,sprintf('HeatMap_ROI%02.0f_Beat%02d.fig',currentROI,beat)]);
        saveas(heatmapFigNum,[saveFolder,filesep,sprintf('HeatMap_ROI%02.0f_Beat%02d.png',currentROI,beat)]);
        savefig(pointPlotFigNum,[saveFolder,filesep,sprintf('PointPlot_ROI%02.0f_Beat%02d.fig',currentROI,beat)])
        saveas(pointPlotFigNum,[saveFolder,filesep,sprintf('PointPlot_ROI%02.0f_Beat%02d.png',currentROI,beat)]);
    end
end


pause(1)
outputLabels = {'ROI','Cycle Number','Propagation Velocity','robust_s'}
conductionOutput
save([saveFolder,filesep,'CPV_OutputData.mat'],'outputLabels','conductionOutput')
